<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BlackNote</title>
  <link rel="icon" type="image/png" href="/assets/BN.png" id="favicon">
  <link rel="stylesheet" href="/css/blacknote.css">
  
  <style>
    /* Badge styles */
    .badge-container {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #333;
    }
    
    .badge-display {
      display: flex;
      justify-content: center;
      margin-bottom: 0.5rem;
    }
    
    .badge-icon {
      width: 64px;
      height: 64px;
      border-radius: 8px;
      object-fit: cover;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    /* Badge next to username in profile */
    .profile-header-with-badge {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      justify-content: center;
    }
    
    .profile-badge-small {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      object-fit: cover;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .badge-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .badge-option {
      width: 100%;
      aspect-ratio: 1;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      overflow: hidden;
      background-size: cover;
      background-position: center;
    }
    
    .badge-option:hover {
      transform: scale(1.05);
      border-color: #666;
    }
    
    .badge-option.selected {
      border-color: #1DA1F2;
      box-shadow: 0 0 12px rgba(29, 161, 242, 0.5);
    }
    
    .badge-option.red { background-color: #ef4444; }
    .badge-option.gold { background-color: #fbbf24; }
    .badge-option.blue { background-color: #3b82f6; }
    .badge-option.green { background-color: #10b981; }
    .badge-option.white { background-color: #f3f4f6; }
    .badge-option.black { background-color: #1f2937; }
    .badge-option.pink { background-color: #ec4899; }
    
    /* Collapsible create post - NOW COMPACT BUTTON */
    .create-post-button-container {
      padding: 1rem;
      background: #1a1a1a;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid #2a2a2a;
    }
    
    .create-post-compact-btn {
      width: 100%;
      padding: 1rem;
      background: linear-gradient(135deg, #1DA1F2, #0d8bd9);
      border: none;
      border-radius: 10px;
      color: white;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      box-shadow: 0 4px 12px rgba(29, 161, 242, 0.3);
    }
    
    .create-post-compact-btn:hover {
      background: linear-gradient(135deg, #1a8cd8, #0c7ac4);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(29, 161, 242, 0.4);
    }
    
    .create-post-compact-btn:active {
      transform: translateY(0);
    }
    
    /* Create Post Modal - FULLSCREEN */
    .create-post-modal {
      position: fixed;
      top: 80px;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }
    
    .create-post-modal.visible {
      opacity: 1;
      pointer-events: all;
    }
    
    .create-post-modal-content {
      background: #0a0a0a;
      width: 100%;
      height: 100%;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      transform: translateY(20px);
      transition: transform 0.2s ease;
    }
    
    .create-post-modal.visible .create-post-modal-content {
      transform: translateY(0);
    }
    
    .create-post-modal-header {
      padding: 1.5rem 2rem;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      background: #1a1a1a;
    }
    
    .create-post-modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: white;
    }
    
    .create-post-close-btn {
      background: none;
      border: none;
      color: #888;
      font-size: 2rem;
      cursor: pointer;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    
    .create-post-close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }
    
    .create-post-modal-body {
      flex: 1;
      padding: 2rem;
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .create-post-textarea {
      width: 100%;
      flex: 1;
      min-height: 300px;
      padding: 1.5rem;
      background: #1a1a1a;
      border: 2px solid #333;
      border-radius: 12px;
      color: white;
      font-size: 1.1rem;
      resize: none;
      transition: border-color 0.2s;
      font-family: inherit;
    }
    
    .create-post-textarea:focus {
      outline: none;
      border-color: #1DA1F2;
    }
    
    .create-post-media {
      margin: 1.5rem 0;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .media-upload-btn {
      padding: 0.75rem 1.5rem;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-block;
    }
    
    .media-upload-btn:hover {
      background: #333;
      border-color: #1DA1F2;
    }
    
    .file-name {
      color: #888;
      font-size: 0.9rem;
      flex: 1;
    }
    
    .remove-media-btn {
      padding: 0.5rem;
      background: #ef4444;
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      display: none;
      width: 32px;
      height: 32px;
      align-items: center;
      justify-content: center;
    }
    
    .remove-media-btn:hover {
      background: #dc2626;
    }
    
    .create-post-actions {
      display: flex;
      justify-content: flex-end;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    
    .create-post-cancel-btn {
      padding: 0.75rem 1.5rem;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .create-post-cancel-btn:hover {
      background: #333;
    }
    
    .post-btn {
      padding: 0.75rem 2rem;
      background: #1DA1F2;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .post-btn:hover {
      background: #1a8cd8;
    }
    
    .post-btn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }
    
    /* Friends under profile */
    .left .friends-section {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .friends-section .panel {
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    
    .friends-section h3 {
      margin: 0 0 1rem 0;
      font-size: 1.25rem;
      font-weight: 700;
      flex-shrink: 0;
    }
    
    .friends-list {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 0.5rem;
    }
    
    .friends-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .friends-list::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 3px;
    }
    
    .friends-list::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 3px;
    }
    
    .friends-list::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    
    .left {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      max-height: calc(100vh - 80px);
      padding: 0;
      width: 420px; 
      min-width: 420px;
    }
    
    .left > .panel {
      flex-shrink: 0;
      margin: 0;
    }
    
    /* Friends section with max height */
    .left .friends-section {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    
    /* Friend item with 3-dot menu */
    .friend-item {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      border-radius: 8px;
      transition: background-color 0.2s;
      margin-bottom: 0.5rem;
    }
    
    .friend-item:hover {
      background-color: rgba(255,255,255,0.05);
    }
    
    .friend-menu-btn {
      margin-left: auto;
      background: none;
      border: none;
      color: #888;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .friend-menu-btn:hover {
      background-color: rgba(255,255,255,0.1);
      color: #fff;
    }
    
    .friend-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0.5rem;
      min-width: 150px;
      z-index: 100;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    
    .friend-dropdown.visible {
      display: block;
    }
    
    .friend-dropdown button {
      display: block;
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: none;
      border: none;
      color: white;
      text-align: left;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    
    .friend-dropdown button:hover {
      background-color: rgba(255,255,255,0.1);
    }
    
    /* Scroll snap for posts */
    .feed {
      height: calc(100vh - 80px);
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      scrollbar-width: none;
      -ms-overflow-style: none;
      scroll-behavior: smooth;
    }
    
    .feed::-webkit-scrollbar {
      display: none;
    }
    
    .post {
      scroll-snap-align: start;
      scroll-snap-stop: always;
      min-height: calc(100vh - 80px);
      max-height: calc(100vh - 80px);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      margin-bottom: 0;
      padding: 1.5rem;
    }
    
    .post-body {
      max-height: 300px;
      overflow-y: auto;
      padding: 1rem 0;
      margin: 1rem 0;
    }
    
    .post-actions {
      margin-top: auto;
      padding-top: 1rem;
      border-top: 1px solid #333;
    }
    
    /* Ensure posts fill the viewport */
    .center {
      height: calc(100vh - 80px);
      overflow: hidden;
      margin-left: 120px; 
      margin-right: 120px;
    }
    
    .create-post-panel {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #1a1a1a;
    }
    
    /* Comments sidebar */
    .comments-sidebar {
      position: fixed;
      right: 0;
      top: 80px;
      width: 500px;
      height: calc(100vh - 80px);
      background: #1a1a1a;
      border-left: 1px solid #333;
      display: flex;
      flex-direction: column;
      z-index: 50;
      border-top-left-radius: 12px; 
      border-bottom-left-radius: 12px; 
    }
    
    .comments-sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid #333;
      font-weight: 600;
      font-size: 1.1rem;
    }
    
    .comments-sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }
    
    .sidebar-comment {
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #333;
      position: relative;
    }
    
    .comment-menu-toggle {
      position: absolute;
      top: 0;
      right: 0;
      background: none;
      border: none;
      color: #888;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .comment-menu-toggle:hover {
      background-color: rgba(255,255,255,0.1);
      color: #fff;
    }
    
    .comment-dropdown {
      position: absolute;
      top: 30px;
      right: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0.5rem;
      min-width: 120px;
      z-index: 100;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    
    .comment-dropdown.visible {
      display: block;
    }
    
    .comment-dropdown button {
      display: block;
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: none;
      border: none;
      color: white;
      text-align: left;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.2s;
      font-size: 0.9rem;
    }
    
    .comment-dropdown button:hover {
      background-color: rgba(255,255,255,0.1);
    }
    
    .comment-dropdown button.danger {
      color: #ef4444;
    }
    
    .comments-sidebar-form {
      padding: 1rem;
      border-top: 1px solid #333;
      display: flex;
      gap: 0.5rem;
    }
    
    .comments-sidebar-input {
      flex: 1;
      padding: 0.75rem;
      background: #2a2a2a;
      border: 1px solid #333;
      border-radius: 8px;
      color: white;
    }
    
    .comments-sidebar-submit {
      padding: 0.75rem 1.5rem;
      background: #1DA1F2;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .comments-sidebar-submit:hover {
      background: #1a8cd8;
    }

    /* Main Layout - NEW DESIGN */
    .layout {
      max-width: 100%;
      margin: 0;
      padding: 0;
      display: grid;
      grid-template-columns: 320px 1fr 400px;
      gap: 0;
      align-items: start;
      height: 100vh;
      overflow: hidden;
      position: fixed;
      top: 80px;
      left: 0;
      right: 0;
      bottom: 0;
    }
    
    .left {
      height: 100%;
      overflow-y: auto;
      border-right: 1px solid #333;
    }
    
    .center {
      height: 100%;
      overflow: hidden;
      position: relative;
    }
    
    .right {
      height: 100%;
      overflow: hidden;
    }
    
    @media (max-width: 1024px) {
        .layout { 
          grid-template-columns: 1fr; 
        }
        .left .friends-section, .right { 
          display: none; 
        }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Loading and end of feed states */
    .loading-indicator,
    .end-of-feed {
      scroll-snap-align: none;
      min-height: auto;
      max-height: none;
      padding: 1rem;
    }
    
    .empty-feed-message {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 80px);
      color: #888;
      font-size: 1.1rem;
      text-align: center;
      padding: 2rem;
    }
  </style>
</head>

<body>
  <header class="topbar">
  <div class="left-section">
    <button id="menuToggle" class="hamburger" aria-label="Open menu" aria-expanded="false" title="Menu">
      <span></span><span></span><span></span>
    </button>
    <a href="/pages/blacknote.html">
      <img src="/assets/blacknotetrans.png" alt="Logo" class="logo" />
    </a>
  </div>

  <div class="center-section">
    <div class="search-container">
      <input type="text" class="search-box" placeholder="Search..." />
    </div>
  </div>

<div class="right-section">

<a href="#" id="notification-bell-link" class="icon-btn" title="Notifications" style="margin-left: 15px; margin-right: 30px;">
    <img src="/assets/notif.png" alt="Notifications" class="custom-emoji">
</a>
 <a href="/pages/noteai.html" class="icon-btn" title="Ai Assistant">
    <img src="/assets/gem.png" alt="Gemini" class="custom-emoji">
  </a>

<a href="/pages/blacknote.html" class="icon-btn" title="home">
    <img src="/assets/home.png" alt="home" class="custom-emoji">
  </a>
  <a href="/pages/friendsblacknote.html" class="icon-btn" title="Add">
    <img src="/assets/add.png" alt="Add" class="custom-emoji">
  </a>
  <a href="/pages/mapblacknote.html" class="icon-btn" title="Basketball">
    <img src="/assets/ball.png" alt="Basketball" class="custom-emoji">
  </a>
  <a href="/pages/dripblacknote.html" class="icon-btn" title="Black Market">
    <img src="/assets/shop.png" alt="Money" class="custom-emoji">
  </a>
  <a href="/pages/hollablacknote.html" class="icon-btn" title="Holla">
    <img src="/assets/hol.png" alt="Holla" class="custom-emoji">
  </a>
</div>

</header>

<nav id="slideMenu" class="slide-menu" aria-hidden="true" role="navigation">
  <div class="slide-menu-inner" role="menu" aria-label="Site menu">
    <button id="contactBtn" class="menu-item" role="menuitem">Contact Us!</button>
    <button id="aboutBtn" class="menu-item" role="menuitem">About</button>
    <button id="logoutBtn" class="menu-item login-btn" role="menuitem">Logout</button>
  </div>
</nav>
<div id="menuOverlay" class="menu-overlay" aria-hidden="true"></div>

  <div id="offline-banner" class="offline-banner">You are offline ‚Äî some features may be unavailable.</div>

<div class="layout">
  <!-- Left column -->
  <aside class="left">
    <div class="panel profile-center">
      <input id="pfp-upload" type="file" accept="image/*" style="display:none;">
      <div id="profile-pic" class="profile-pic" title="Profile picture (open Edit Profile to change)"></div>
      
      <!-- Badge next to username -->
      <div class="profile-header-with-badge">
        <div id="profile-badge-display"></div>
        <div class="profile-name main-profile-name">Black Note</div>
      </div>
      
      <div class="profile-bio" id="profile-bio">Stand-in bio: creative, coffee lover, building BlackNote.</div>
      
      <button class="post-btn edit-profile-btn" id="open-profile-editor">Edit Profile</button>
    </div>
    
    <!-- Create Post Button in Container -->
    <div class="create-post-button-container">
      <button class="create-post-compact-btn" id="open-create-post">
        ‚úèÔ∏è Create Post
      </button>
    </div>
    
    <!-- Friends moved under profile -->
    <div class="friends-section">
      <div class="panel">
        <h3>Friends</h3>
        <div class="friends-list" id="friends-container"></div>
      </div>
    </div>
  </aside>

  <!-- Center column -->
  <main class="center">
    <div class="feed" id="feed-container"></div>
  </main>

  <!-- Right column - Comments Sidebar -->
  <aside class="right">
    <div class="comments-sidebar">
      <div class="comments-sidebar-header">Comments</div>
      <div class="comments-sidebar-content" id="sidebar-comments-list">
        <p style="color: #888; text-align: center; padding: 2rem;">Select a post to view comments</p>
      </div>
      <form class="comments-sidebar-form" id="sidebar-comment-form" style="display: none;">
        <input type="text" class="comments-sidebar-input" placeholder="Add a comment..." id="sidebar-comment-input" required>
        <button type="submit" class="comments-sidebar-submit">Post</button>
      </form>
    </div>
  </aside>
</div>

<!-- Create Post Modal - FULLSCREEN -->
<div class="create-post-modal" id="create-post-modal" style="display: none;">
  <div class="create-post-modal-content" onclick="event.stopPropagation();">
    <div class="create-post-modal-header">
      <h2 class="create-post-modal-title">Create a New Post</h2>
      <button class="create-post-close-btn" id="close-create-modal" type="button">&times;</button>
    </div>
    <div class="create-post-modal-body">
      <textarea class="create-post-textarea" placeholder="What's on your mind?" id="new-post-text"></textarea>

      <div class="create-post-media">
        <label for="new-post-media" class="media-upload-btn">
          üìé Attach Media
        </label>
        <input type="file" id="new-post-media" accept="image/*,video/*" style="display:none;">
        <span id="file-name" class="file-name">No file chosen</span>
        <button id="remove-media" class="remove-media-btn" title="Remove file" type="button">‚úñ</button>
      </div>

      <div class="create-post-actions">
        <button class="create-post-cancel-btn" id="cancel-create-post" type="button">Cancel</button>
        <button class="post-btn" id="create-post-btn" type="button">Post</button>
      </div>
    </div>
  </div>
</div>

  <div id="profile-editor-modal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="profile-modal-title">
      <button class="close-modal-btn" id="close-modal" aria-label="Close" style="position:absolute; top:1rem; right:1rem; background:none; border:none; font-size:2rem; color:var(--muted); cursor:pointer;">&times;</button>
      <h2 id="profile-modal-title" style="margin-top:0;">Edit Profile</h2>
      <form id="profile-edit-form">
        <label for="pfp-upload-modal">Profile Picture</label>
        <label for="pfp-upload-modal" style="cursor:pointer;">
          <img id="pfp-preview" src="/assets/BN.png" alt="Profile preview">
        </label>
        <input type="file" id="pfp-upload-modal" accept="image/*" style="display:none;">

        <label for="username-input">Username</label>
        <input type="text" id="username-input" value="Black Note" autocomplete="off">
        <p id="username-cooldown-msg" aria-live="polite"></p>

        <label for="bio-input">Bio</label>
        <textarea id="bio-input" placeholder="Write a short bio..."></textarea>

        <!-- Badge Selection -->
        <label>Choose Your Badge</label>
        <div class="badge-selector" id="badge-selector">
          <div class="badge-option red" data-badge="red" title="Red Badge"></div>
          <div class="badge-option gold" data-badge="gold" title="Gold Badge"></div>
          <div class="badge-option blue" data-badge="blue" title="Blue Badge"></div>
          <div class="badge-option green" data-badge="green" title="Green Badge"></div>
          <div class="badge-option white" data-badge="white" title="White Badge"></div>
          <div class="badge-option black" data-badge="black" title="Black Badge"></div>
          <div class="badge-option pink" data-badge="pink" title="Pink Badge"></div>
        </div>

        <button type="submit" id="save-profile-btn" class="post-btn" style="width: 100%; margin-top: 1rem;">Save Changes</button>
      </form>
    </div>
  </div>

  <!-- Compression Progress Toast -->
  <div id="compression-toast" style="position: fixed; bottom: 20px; right: 20px; background: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 1rem 1.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 10001; display: none;">
    <div style="display: flex; align-items: center; gap: 0.75rem;">
      <div class="spinner" style="width: 20px; height: 20px; border: 2px solid #333; border-top-color: #1DA1F2; border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
      <div>
        <div style="font-weight: 600; color: white; margin-bottom: 0.25rem;" id="toast-title">Compressing media...</div>
        <div style="font-size: 0.875rem; color: #888;" id="toast-message">Please wait</div>
      </div>
    </div>
  </div>

<script type="module">
  import { 
    supabase, 
    uploadImageForUser, 
    onAuthStateChanged, 
    startGlobalNotifications,
    getUserProfile,
    updateUserProfile
  } from '/javascript/supabase.js';

  const COOLDOWN_HOURS = 24;
  const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB in bytes
  const MAX_VIDEO_SIZE = 10 * 1024 * 1024; // 10MB for videos (strict limit)
  const MAX_VIDEO_DURATION = 30; // 30 seconds max
  const MAX_IMAGE_SIZE_BEFORE_COMPRESSION = 50 * 1024 * 1024; // 50MB - will try to compress
  
  // Toast notification functions
  function showToast(title, message) {
    const toast = document.getElementById('compression-toast');
    const toastTitle = document.getElementById('toast-title');
    const toastMessage = document.getElementById('toast-message');
    
    toastTitle.textContent = title;
    toastMessage.textContent = message;
    toast.style.display = 'block';
  }
  
  function hideToast() {
    const toast = document.getElementById('compression-toast');
    toast.style.display = 'none';
  }
  
  // Compress image using Canvas API
  async function compressImage(file, maxSizeMB = 10) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;
          
          // Calculate new dimensions (max 1920px width for optimal balance)
          const maxWidth = 1920;
          const maxHeight = 1920;
          
          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }
          
          if (height > maxHeight) {
            width = (width * maxHeight) / height;
            height = maxHeight;
          }
          
          canvas.width = width;
          canvas.height = height;
          
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          
          // Try different quality levels until we get under the size limit
          let quality = 0.9;
          const tryCompress = () => {
            canvas.toBlob(
              (blob) => {
                if (!blob) {
                  reject(new Error('Compression failed'));
                  return;
                }
                
                const sizeMB = blob.size / (1024 * 1024);
                console.log(`üìè Compressed to ${sizeMB.toFixed(2)}MB at quality ${quality}`);
                
                if (sizeMB <= maxSizeMB || quality <= 0.1) {
                  // Success or we've tried our best
                  const compressedFile = new File([blob], file.name, {
                    type: 'image/jpeg',
                    lastModified: Date.now()
                  });
                  resolve(compressedFile);
                } else {
                  // Try again with lower quality
                  quality -= 0.1;
                  tryCompress();
                }
              },
              'image/jpeg',
              quality
            );
          };
          
          tryCompress();
        };
        
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = e.target.result;
      };
      
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsDataURL(file);
    });
  }
  
  // Process uploaded file with compression and validation
  async function processUploadedFile(file) {
    console.log(`üìÅ Processing file: ${file.name} (${(file.size / (1024 * 1024)).toFixed(2)}MB)`);
    
    // Check if file exceeds limit
    if (file.size > MAX_FILE_SIZE) {
      const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
      
      if (file.type.startsWith('image/')) {
        // Try to compress the image
        showToast('Compressing image...', `Original size: ${sizeMB}MB`);
        
        try {
          const compressed = await compressImage(file, 10);
          const newSizeMB = (compressed.size / (1024 * 1024)).toFixed(2);
          
          console.log(`‚úÖ Image compressed: ${sizeMB}MB ‚Üí ${newSizeMB}MB`);
          hideToast();
          
          if (compressed.size > MAX_FILE_SIZE) {
            alert(`Image is still too large after compression (${newSizeMB}MB). Please choose a smaller image.`);
            return null;
          }
          
          return compressed;
        } catch (err) {
          console.error('‚ùå Compression failed:', err);
          hideToast();
          alert('Failed to compress image. Please try a different file.');
          return null;
        }
      } else if (file.type.startsWith('video/')) {
        // Videos can't be easily compressed in browser
        hideToast();
        alert(`Video file is too large (${sizeMB}MB). Maximum size is 10MB.\n\nTip: Use a video compression tool before uploading.`);
        return null;
      } else {
        hideToast();
        alert(`File is too large (${sizeMB}MB). Maximum size is 10MB.`);
        return null;
      }
    }
    
    // File is under limit
    if (file.type.startsWith('image/')) {
      // Still compress images for optimal storage
      showToast('Optimizing image...', 'This will only take a moment');
      
      try {
        const compressed = await compressImage(file, 10);
        const originalMB = (file.size / (1024 * 1024)).toFixed(2);
        const newSizeMB = (compressed.size / (1024 * 1024)).toFixed(2);
        const savings = ((1 - compressed.size / file.size) * 100).toFixed(0);
        
        console.log(`‚úÖ Image optimized: ${originalMB}MB ‚Üí ${newSizeMB}MB (${savings}% smaller)`);
        hideToast();
        
        return compressed;
      } catch (err) {
        console.error('‚ö†Ô∏è Optimization failed, using original:', err);
        hideToast();
        return file; // Fallback to original if compression fails
      }
    }
    
    // Videos under 10MB are OK
    return file;
  }
  
  // Badge selection functionality
  const badgeSelector = document.getElementById('badge-selector');
  const badgeDisplay = document.getElementById('profile-badge-display');
  let selectedBadge = null;
  let currentPostId = null; // Track currently visible post
  
  // Wait for DOM to be ready before accessing elements
  let createPostBtn = null;
  let openCreatePostBtn = null;
  let createPostModal = null;
  let closeCreateModal = null;
  let cancelCreatePost = null;
  let createPostTextarea = null;
  let selectedMediaFile = null; // Store processed file
  
  // Initialize create post elements after DOM is loaded
  function initCreatePostModal() {
    openCreatePostBtn = document.getElementById('open-create-post');
    createPostModal = document.getElementById('create-post-modal');
    closeCreateModal = document.getElementById('close-create-modal');
    cancelCreatePost = document.getElementById('cancel-create-post');
    createPostTextarea = document.getElementById('new-post-text');
    createPostBtn = document.getElementById('create-post-btn');
    const mediaInput = document.getElementById('new-post-media');
    const removeMediaBtn = document.getElementById('remove-media');
    const fileNameEl = document.getElementById('file-name');
    
    console.log('üîß Create post elements initialized:', {
      button: !!openCreatePostBtn,
      modal: !!createPostModal,
      closeBtn: !!closeCreateModal,
      cancelBtn: !!cancelCreatePost,
      textarea: !!createPostTextarea,
      postBtn: !!createPostBtn
    });
    
    // Handle media file selection with compression
    if (mediaInput) {
      mediaInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        console.log(`üìé File selected: ${file.name}`);
        
        // Process and compress the file
        const processedFile = await processUploadedFile(file);
        
        if (processedFile) {
          selectedMediaFile = processedFile;
          const sizeMB = (processedFile.size / (1024 * 1024)).toFixed(2);
          fileNameEl.textContent = `${processedFile.name} (${sizeMB}MB)`;
          fileNameEl.style.color = '#1DA1F2';
          
          if (removeMediaBtn) {
            removeMediaBtn.style.display = 'inline-block';
          }
        } else {
          // Processing failed or file was rejected
          mediaInput.value = '';
          selectedMediaFile = null;
          fileNameEl.textContent = 'No file chosen';
          fileNameEl.style.color = '';
          
          if (removeMediaBtn) {
            removeMediaBtn.style.display = 'none';
          }
        }
      });
    }
    
    // Handle remove media button
    if (removeMediaBtn) {
      removeMediaBtn.addEventListener('click', () => {
        selectedMediaFile = null;
        if (mediaInput) mediaInput.value = '';
        fileNameEl.textContent = 'No file chosen';
        fileNameEl.style.color = '';
        removeMediaBtn.style.display = 'none';
      });
    }
    
    if (openCreatePostBtn) {
      openCreatePostBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('üñ±Ô∏è Create post button clicked');
        openCreatePostModal();
      });
    }
    
    if (closeCreateModal) {
      closeCreateModal.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeCreatePostModal();
      });
    }
    
    if (cancelCreatePost) {
      cancelCreatePost.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeCreatePostModal();
      });
    }
    
    if (createPostModal) {
      createPostModal.addEventListener('click', (e) => {
        if (e.target === createPostModal) {
          closeCreatePostModal();
        }
      });
    }
    
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && createPostModal && createPostModal.style.display === 'block') {
        closeCreatePostModal();
      }
    });
  }
  
  function openCreatePostModal() {
    console.log('üìù Opening create post modal');
    if (createPostModal) {
      createPostModal.style.display = 'block';
      setTimeout(() => {
        createPostModal.classList.add('visible');
        if (createPostTextarea) createPostTextarea.focus();
      }, 10);
    }
  }
  
  function closeCreatePostModal() {
    console.log('‚ùå Closing create post modal');
    if (createPostModal) {
      createPostModal.classList.remove('visible');
      setTimeout(() => {
        createPostModal.style.display = 'none';
      }, 200);
    }
    if (createPostTextarea) createPostTextarea.value = '';
    const fileNameEl = document.getElementById('file-name');
    const mediaInput = document.getElementById('new-post-media');
    const removeMediaBtn = document.getElementById('remove-media');
    
    if (fileNameEl) {
      fileNameEl.textContent = 'No file chosen';
      fileNameEl.style.color = '';
    }
    if (mediaInput) mediaInput.value = '';
    if (removeMediaBtn) removeMediaBtn.style.display = 'none';
    selectedMediaFile = null; // Clear processed file
  }
  
  /* 
   * IMPORTANT: When creating a post, use selectedMediaFile instead of reading from the input:
   * 
   * Example:
   * createPostBtn.addEventListener('click', async () => {
   *   const text = createPostTextarea.value;
   *   
   *   // Use selectedMediaFile which is already compressed
   *   if (selectedMediaFile) {
   *     const mediaUrl = await uploadImageForUser(selectedMediaFile, fbUser.id);
   *     // Create post with text and mediaUrl
   *   } else {
   *     // Create post with just text
   *   }
   * });
   */
  
  badgeSelector.addEventListener('click', (e) => {
    const option = e.target.closest('.badge-option');
    if (!option) return;
    
    // Remove previous selection
    badgeSelector.querySelectorAll('.badge-option').forEach(b => b.classList.remove('selected'));
    
    // Mark as selected
    option.classList.add('selected');
    selectedBadge = option.dataset.badge;
  });
  
  function displayBadge(badgeColor, targetElement = badgeDisplay) {
    if (!badgeColor) {
      targetElement.innerHTML = '';
      return;
    }
    
    // Create badge image
    const badgeImg = document.createElement('img');
    badgeImg.className = 'profile-badge-small';
    badgeImg.src = `/assets/badges/${badgeColor}.png`;
    badgeImg.alt = `${badgeColor} badge`;
    badgeImg.onerror = () => {
      // Fallback to colored div if image not found
      const fallback = document.createElement('div');
      fallback.className = 'profile-badge-small';
      fallback.style.backgroundColor = badgeColor === 'white' ? '#f3f4f6' : badgeColor;
      targetElement.innerHTML = '';
      targetElement.appendChild(fallback);
    };
    
    targetElement.innerHTML = '';
    targetElement.appendChild(badgeImg);
  }
  
  // Scroll detection for posts
  function setupScrollSnap() {
    const feedEl = document.getElementById('feed-container');
    if (!feedEl) return;
    
    let scrollTimeout;
    let isScrolling = false;
    
    feedEl.addEventListener('scroll', () => {
      isScrolling = true;
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
        detectCurrentPost();
      }, 100);
    });
    
    // Also detect on scroll end with IntersectionObserver
    const posts = feedEl.querySelectorAll('.post');
    const observerOptions = {
      root: feedEl,
      threshold: 0.5
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !isScrolling) {
          const postId = entry.target.dataset.postId;
          if (postId !== currentPostId) {
            currentPostId = postId;
            loadCommentsForPost(postId);
          }
        }
      });
    }, observerOptions);
    
    posts.forEach(post => observer.observe(post));
  }
  
  // Infinite scroll detection
  function setupInfiniteScroll() {
    const feedEl = document.getElementById('feed-container');
    if (!feedEl) return;
    
    const loadingIndicator = feedEl.querySelector('.loading-indicator');
    if (!loadingIndicator) return;
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && hasMorePosts && !isLoadingMore) {
          console.log('üìú Loading more posts...');
          loadMorePosts();
        }
      });
    }, {
      root: feedEl,
      threshold: 0.1,
      rootMargin: '100px'
    });
    
    observer.observe(loadingIndicator);
  }
  
  function detectCurrentPost() {
    const feedEl = document.getElementById('feed-container');
    const posts = feedEl.querySelectorAll('.post');
    
    let currentPost = null;
    let minDistance = Infinity;
    
    posts.forEach(post => {
      const rect = post.getBoundingClientRect();
      const feedRect = feedEl.getBoundingClientRect();
      const distance = Math.abs(rect.top - feedRect.top);
      
      if (distance < minDistance) {
        minDistance = distance;
        currentPost = post;
      }
    });
    
    if (currentPost) {
      const postId = currentPost.dataset.postId;
      if (postId !== currentPostId) {
        currentPostId = postId;
        loadCommentsForPost(postId);
      }
    }
  }
  
  async function loadCommentsForPost(postId) {
    const post = findPostById(postId);
    if (!post) return;
    
    const commentsList = document.getElementById('sidebar-comments-list');
    const commentForm = document.getElementById('sidebar-comment-form');
    const commentInput = document.getElementById('sidebar-comment-input');
    
    commentsList.innerHTML = '';
    commentForm.style.display = 'flex';
    commentForm.dataset.postId = postId;
    
    if (!post.comments || post.comments.length === 0) {
      commentsList.innerHTML = '<p style="color: #888; text-align: center; padding: 2rem;">No comments yet. Be the first!</p>';
      return;
    }
    
    post.comments.forEach(comment => {
      if (!comment) return;
      
      const commentDiv = document.createElement('div');
      commentDiv.className = 'sidebar-comment';
      commentDiv.dataset.commentId = comment.id;
      
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.alignItems = 'center';
      header.style.gap = '0.5rem';
      header.style.marginBottom = '0.5rem';
      header.style.paddingRight = '2rem';
      
      const avatar = avatarElement(comment.author, comment.avatar, 32);
      avatar.style.flexShrink = '0';
      header.appendChild(avatar);
      
      const author = document.createElement('div');
      author.style.fontWeight = '600';
      author.style.color = 'white';
      author.textContent = comment.author;
      header.appendChild(author);
      
      commentDiv.appendChild(header);
      
      const text = document.createElement('p');
      text.className = 'comment-text-content';
      text.style.color = '#ddd';
      text.style.margin = '0';
      text.style.wordBreak = 'break-word';
      text.textContent = comment.text;
      commentDiv.appendChild(text);
      
      // Check permissions
      const isCommentAuthor = fbUser && (comment.authorUid ? comment.authorUid === fbUser.uid : (fbProfile && comment.author === fbProfile.name));
      const isPostAuthor = fbUser && (post.authorUid ? post.authorUid === fbUser.uid : (fbProfile && post.author === fbProfile.name));
      
      if (isCommentAuthor || isPostAuthor) {
        // Menu toggle button
        const menuToggle = document.createElement('button');
        menuToggle.className = 'comment-menu-toggle';
        menuToggle.innerHTML = '‚ãÆ';
        
        // Dropdown menu
        const dropdown = document.createElement('div');
        dropdown.className = 'comment-dropdown';
        
        if (isCommentAuthor) {
          const editBtn = document.createElement('button');
          editBtn.textContent = 'Edit';
          editBtn.addEventListener('click', async () => {
            const newText = prompt('Edit your comment:', comment.text);
            if (newText === null || newText.trim() === '') return;
            
            try {
              const { data: postData } = await supabase
                .from('posts')
                .select('comments')
                .eq('id', postId)
                .single();
              
              if (!postData) return;
              
              const updatedComments = (postData.comments || []).map(c =>
                c.id === comment.id ? { ...c, text: newText.trim() } : c
              );
              
              await supabase
                .from('posts')
                .update({ comments: updatedComments })
                .eq('id', postId);
              
              console.log('‚úÖ Comment edited');
              dropdown.classList.remove('visible');
            } catch (err) {
              console.error('‚ùå Failed to edit comment:', err);
              alert('Failed to update comment.');
            }
          });
          dropdown.appendChild(editBtn);
        }
        
        if (isCommentAuthor || isPostAuthor) {
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'danger';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', async () => {
            if (!confirm('Delete this comment?')) return;
            
            try {
              const { data: postData } = await supabase
                .from('posts')
                .select('comments')
                .eq('id', postId)
                .single();
              
              if (!postData) return;
              
              const updatedComments = (postData.comments || []).filter(c => c.id !== comment.id);
              
              await supabase
                .from('posts')
                .update({ comments: updatedComments })
                .eq('id', postId);
              
              console.log('üóëÔ∏è Comment deleted');
              dropdown.classList.remove('visible');
            } catch (err) {
              console.error('‚ùå Failed to delete comment:', err);
              alert('Failed to delete comment.');
            }
          });
          dropdown.appendChild(deleteBtn);
        }
        
        // Toggle dropdown
        menuToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          // Close other dropdowns
          document.querySelectorAll('.comment-dropdown.visible').forEach(d => {
            if (d !== dropdown) d.classList.remove('visible');
          });
          dropdown.classList.toggle('visible');
        });
        
        commentDiv.appendChild(menuToggle);
        commentDiv.appendChild(dropdown);
      }
      
      commentsList.appendChild(commentDiv);
    });
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.sidebar-comment')) {
        document.querySelectorAll('.comment-dropdown.visible').forEach(d => {
          d.classList.remove('visible');
        });
      }
    });
  }

  // Start global notifications when user is authenticated
  let authUnsubscribe = null;

  // DOM refs
  const feedEl = document.getElementById('feed-container');
  const friendsEl = document.getElementById('friends-container');
  const profilePicEl = document.getElementById('profile-pic');
  const profileBioEl = document.getElementById('profile-bio');

  const profileModal = document.getElementById('profile-editor-modal');
  const pfpPreview = document.getElementById('pfp-preview');
  const pfpUploadModal = document.getElementById('pfp-upload-modal');
  const usernameInput = document.getElementById('username-input');
  const bioInput = document.getElementById('bio-input');
  const saveProfileBtn = document.getElementById('save-profile-btn');
  const openProfileEditorBtn = document.getElementById('open-profile-editor');
  const offlineBanner = document.getElementById('offline-banner');

  // Notification system
  let notificationPanel = null;
  let notificationBadge = null;
  let notifications = [];
  let lastSeenPostIds = new Set();
  let postsSubscription = null;
  let notificationInitTime = null;

  // Load notification state from localStorage
  function loadNotificationState() {
    try {
      const saved = localStorage.getItem('notificationState');
      if (saved) {
        const state = JSON.parse(saved);
        lastSeenPostIds = new Set(state.lastSeenPostIds || []);
        notificationInitTime = state.initTime || null;
        notifications = (state.notifications || []).filter(n => {
          return (Date.now() - n.timestamp) < (60 * 60 * 1000);
        });
        console.log('üì± Loaded notification state:', lastSeenPostIds.size, 'posts seen');
      } else {
        notificationInitTime = Date.now();
        saveNotificationState();
      }
    } catch (err) {
      console.error('Failed to load notification state:', err);
      notificationInitTime = Date.now();
    }
  }

  // Save notification state to localStorage
  function saveNotificationState() {
    try {
      const state = {
        lastSeenPostIds: Array.from(lastSeenPostIds),
        initTime: notificationInitTime,
        notifications: notifications
      };
      localStorage.setItem('notificationState', JSON.stringify(state));
    } catch (err) {
      console.error('Failed to save notification state:', err);
    }
  }

  // runtime state
  let fbUser = null;
  let fbProfile = null;
  let posts = [];
  let profileUnsub = null;
  let friendsUnsub = null;
  
  // Pagination state
  let currentPage = 0;
  const POSTS_PER_PAGE = 20;
  let isLoadingMore = false;
  let hasMorePosts = true;

  /* ------------------ small helpers ------------------ */
  function escapeHtml(str) {
    if (!str) return '';
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function avatarElement(name, imgUrl, size = 48) {
    const wrapper = document.createElement('div');
    wrapper.className = 'avatar';
    wrapper.style.width = size + 'px';
    wrapper.style.height = size + 'px';
    if (imgUrl && String(imgUrl).startsWith('http')) {
      const img = document.createElement('img');
      img.src = imgUrl;
      img.alt = name || '';
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'cover';
      img.style.borderRadius = '50%';
      img.style.display = 'block';

      wrapper.style.overflow = 'hidden';
      wrapper.style.borderRadius = '50%';
      wrapper.innerHTML = '';
      wrapper.appendChild(img);
    } else {
      wrapper.textContent = (name && name[0]) ? name[0].toUpperCase() : '?';
    }
    return wrapper;
  }

  function findPostById(id) {
    return posts.find(p => p.id === id);
  }

  function checkUsernameCooldownUI(profileObj) {
    const last = profileObj?.last_username_change ? new Date(profileObj.last_username_change).getTime() : null;
    const cooldownMsgEl = document.getElementById('username-cooldown-msg');
    if (!last) { 
      usernameInput.disabled = false; 
      cooldownMsgEl.textContent = ''; 
      return; 
    }
    const hoursPassed = (Date.now() - last) / (1000 * 60 * 60);
    if (hoursPassed < COOLDOWN_HOURS) {
      const hoursLeft = Math.ceil(COOLDOWN_HOURS - hoursPassed);
      usernameInput.disabled = true;
      cooldownMsgEl.textContent = `You can change your username again in ${hoursLeft} hour(s).`;
    } else {
      usernameInput.disabled = false; 
      cooldownMsgEl.textContent = '';
    }
  }

  /* ------------------ rendering ------------------ */
  function renderFeed(array, append = false) {
    console.log('üé® Rendering feed with', array.length, 'posts', append ? '(appending)' : '(replacing)');
    
    if (!append) {
      feedEl.innerHTML = '';
    } else {
      // Remove loading indicator if it exists
      const loadingIndicator = feedEl.querySelector('.loading-indicator');
      if (loadingIndicator) loadingIndicator.remove();
    }
    
    const hiddenKey = fbUser ? `hiddenPosts_${fbUser.id}` : 'hiddenPosts_guest';
    const hiddenPosts = JSON.parse(localStorage.getItem(hiddenKey) || '[]');
    const visible = (array || []).filter(p => !hiddenPosts.includes(p.id));
    console.log('üëÅÔ∏è Visible posts after filtering:', visible.length);
    
    if (!visible.length && !append) {
      const d = document.createElement('div');
      d.className = 'empty-feed-message';
      d.textContent = 'No posts yet ‚Äî add friends to bring your feed to life!';
      feedEl.appendChild(d);
      console.log('üì≠ Feed is empty');
      return;
    }

    console.log('‚úÖ Rendering', visible.length, 'posts');
    visible.forEach(post => {
      const article = document.createElement('article');
      article.className = 'post';
      article.dataset.postId = post.id;

      // header
      const header = document.createElement('div');
      header.className = 'post-header';
      const avatarWrap = avatarElement(post.author_name || post.author || '', post.author_avatar || null, 48);
      avatarWrap.addEventListener('click', () => {
        location.href = `profileblacknote.html?user=${encodeURIComponent(post.author_name || post.author || '')}`;
      });
      header.appendChild(avatarWrap);

      const meta = document.createElement('div');
      meta.className = 'meta';
      const authorLink = document.createElement('a');
      authorLink.className = 'author';
      authorLink.href = `profileblacknote.html?user=${encodeURIComponent(post.author_name || post.author || '')}`;
      authorLink.textContent = post.author_name || post.author || 'Unknown';
      meta.appendChild(authorLink);
      const tdiv = document.createElement('div');
      tdiv.className = 'time';
      tdiv.textContent = post.display_time || (post.created_at ? new Date(post.created_at).toLocaleString() : '');
      meta.appendChild(tdiv);
      header.appendChild(meta);

      article.appendChild(header);

      // body
      const body = document.createElement('div');
      body.className = 'post-body';
      const textP = document.createElement('p');
      textP.textContent = post.text || '';
      body.appendChild(textP);
      article.appendChild(body);

      // media
      if (post.media_url) {
        const mediaDiv = document.createElement('div');
        mediaDiv.className = 'post-media';
        if (post.media_type === 'video') {
          const vid = document.createElement('video');
          vid.src = post.media_url;
          vid.controls = true;
          vid.style.maxWidth = '100%';
          vid.style.borderRadius = '8px';
          mediaDiv.appendChild(vid);
        } else {
          const img = document.createElement('img');
          img.src = post.media_url;
          img.alt = 'Post image';
          img.style.maxWidth = '100%';
          img.style.borderRadius = '8px';
          mediaDiv.appendChild(img);
        }
        article.appendChild(mediaDiv);
      }

      // actions
      const actions = document.createElement('div');
      actions.className = 'post-actions';
      
      const likeBtn = document.createElement('button');
      likeBtn.className = 'action-btn like-btn';
      likeBtn.innerHTML = `üëç ${post.likes || 0}`;
      actions.appendChild(likeBtn);

      const commentBtn = document.createElement('button');
      commentBtn.className = 'action-btn';
      commentBtn.innerHTML = `üí¨ ${(post.comments || []).length}`;
      actions.appendChild(commentBtn);

      article.appendChild(actions);
      feedEl.appendChild(article);
    });

    // Add loading indicator or end message
    if (hasMorePosts && visible.length > 0) {
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'loading-indicator';
      loadingDiv.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; padding: 2rem; gap: 0.75rem;">
          <div class="spinner" style="width: 24px; height: 24px; border: 3px solid #333; border-top-color: #1DA1F2; border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
          <span style="color: #888;">Loading more posts...</span>
        </div>
      `;
      feedEl.appendChild(loadingDiv);
      
      /* ALTERNATIVE: Manual "Load More" Button
       * Replace the above with this if you prefer a button instead of infinite scroll:
       * 
       * const loadMoreBtn = document.createElement('button');
       * loadMoreBtn.className = 'load-more-btn';
       * loadMoreBtn.textContent = 'Load More Posts';
       * loadMoreBtn.style.cssText = 'width: 100%; padding: 1rem 2rem; margin: 2rem 0; background: #1DA1F2; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: all 0.2s;';
       * loadMoreBtn.addEventListener('click', loadMorePosts);
       * loadMoreBtn.addEventListener('mouseenter', () => loadMoreBtn.style.background = '#1a8cd8');
       * loadMoreBtn.addEventListener('mouseleave', () => loadMoreBtn.style.background = '#1DA1F2');
       * feedEl.appendChild(loadMoreBtn);
       * 
       * And comment out the setupInfiniteScroll() call below
       */
    } else if (!hasMorePosts && visible.length > 0) {
      const endDiv = document.createElement('div');
      endDiv.className = 'end-of-feed';
      endDiv.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: #888;">
          <p style="margin: 0;">üéâ You're all caught up!</p>
          <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">No more posts to show</p>
        </div>
      `;
      feedEl.appendChild(endDiv);
    }

    if (!append) {
      setupScrollSnap();
      setupInfiniteScroll();
    }
  }

  function renderFriends(friendsList) {
    friendsEl.innerHTML = '';
    if (!friendsList || friendsList.length === 0) {
      friendsEl.innerHTML = '<p style="color:#888;">No friends yet.</p>';
      return;
    }
    friendsList.forEach(fr => {
      const item = document.createElement('div');
      item.className = 'friend-item';
      
      const av = avatarElement(fr.name, fr.avatar, 40);
      item.appendChild(av);
      
      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.fontWeight = '500';
      nameDiv.textContent = fr.name;
      item.appendChild(nameDiv);
      
      friendsEl.appendChild(item);
    });
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    console.log('üìÑ DOM loaded, initializing...');
    initCreatePostModal();
    loadNotificationState();
  });

  // Auth monitoring
  onAuthStateChanged(async (user) => {
    fbUser = user;
    if (!user) {
      console.log('‚ùå No user, redirecting to login');
      window.location.href = '/pages/loginblacknote.html';
      return;
    }

    console.log('‚úÖ User authenticated:', user.email);
    const profile = await getUserProfile(user.id);
    fbProfile = profile;

    if (profile) {
      profilePicEl.style.backgroundImage = profile.avatar ? `url(${profile.avatar})` : '';
      profileBioEl.textContent = profile.bio || 'No bio yet.';
      document.querySelector('.main-profile-name').textContent = profile.name || user.email;
      
      pfpPreview.src = profile.avatar || '/assets/BN.png';
      usernameInput.value = profile.name || '';
      bioInput.value = profile.bio || '';
      
      if (profile.badge) {
        selectedBadge = profile.badge;
        displayBadge(profile.badge);
        const option = badgeSelector.querySelector(`[data-badge="${profile.badge}"]`);
        if (option) option.classList.add('selected');
      }
      
      checkUsernameCooldownUI(profile);
    }

    console.log('üìä Performance: Loading posts with pagination (20 at a time)');
    loadPosts();
    loadFriends();
    
    // Optional: Setup real-time updates for new posts
    // Note: With pagination, new posts will appear on refresh or you can implement
    // a "New posts available" notification at the top
  });

  async function loadPosts() {
    console.log('üì• Loading initial posts (0-19)...');
    currentPage = 0;
    hasMorePosts = true;
    
    const startIndex = 0;
    const endIndex = POSTS_PER_PAGE - 1;
    
    const { data, error } = await supabase
      .from('posts')
      .select('*')
      .order('created_at', { ascending: false })
      .range(startIndex, endIndex);
    
    if (error) {
      console.error('‚ùå Failed to load posts:', error);
      return;
    }
    
    posts = data || [];
    console.log(`‚úÖ Loaded ${posts.length} posts`);
    
    // Check if there might be more posts
    if (posts.length < POSTS_PER_PAGE) {
      hasMorePosts = false;
      console.log('üì≠ No more posts available');
    }
    
    renderFeed(posts, false);
  }

  async function loadMorePosts() {
    if (isLoadingMore || !hasMorePosts) return;
    
    isLoadingMore = true;
    currentPage++;
    
    const startIndex = currentPage * POSTS_PER_PAGE;
    const endIndex = startIndex + POSTS_PER_PAGE - 1;
    
    console.log(`üì• Loading more posts (${startIndex}-${endIndex})...`);
    
    const { data, error } = await supabase
      .from('posts')
      .select('*')
      .order('created_at', { ascending: false })
      .range(startIndex, endIndex);
    
    if (error) {
      console.error('‚ùå Failed to load more posts:', error);
      isLoadingMore = false;
      return;
    }
    
    const newPosts = data || [];
    console.log(`‚úÖ Loaded ${newPosts.length} more posts`);
    
    // Check if we've reached the end
    if (newPosts.length < POSTS_PER_PAGE) {
      hasMorePosts = false;
      console.log('üì≠ Reached end of posts');
    }
    
    // Add new posts to the array
    posts = [...posts, ...newPosts];
    
    // Render the new posts (append mode)
    renderFeed(newPosts, true);
    
    isLoadingMore = false;
    
    // Setup infinite scroll again for the new loading indicator
    if (hasMorePosts) {
      setupInfiniteScroll();
    }
  }

  async function loadFriends() {
    if (!fbUser) return;
    const { data, error } = await supabase
      .from('friends')
      .select('friend_id, profiles(name, avatar)')
      .eq('user_id', fbUser.id);
    
    if (error) {
      console.error('Failed to load friends:', error);
      return;
    }
    
    const friendsList = (data || []).map(f => ({
      id: f.friend_id,
      name: f.profiles?.name || 'Unknown',
      avatar: f.profiles?.avatar || null
    }));
    
    renderFriends(friendsList);
  }

  // Profile editor
  openProfileEditorBtn.addEventListener('click', () => {
    profileModal.setAttribute('aria-hidden', 'false');
    profileModal.style.display = 'flex';
  });

  document.getElementById('close-modal').addEventListener('click', () => {
    profileModal.setAttribute('aria-hidden', 'true');
    profileModal.style.display = 'none';
  });

  pfpUploadModal.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        pfpPreview.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });

  document.getElementById('profile-edit-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!fbUser) return;

    const newUsername = usernameInput.value.trim();
    const newBio = bioInput.value.trim();
    
    let avatarUrl = fbProfile?.avatar || null;
    const file = pfpUploadModal.files[0];
    if (file) {
      avatarUrl = await uploadImageForUser(file, fbUser.id);
    }

    const updates = {
      name: newUsername,
      bio: newBio,
      avatar: avatarUrl,
      badge: selectedBadge
    };

    if (newUsername !== fbProfile?.name) {
      const canChange = await checkUsernameCooldown(fbProfile);
      if (!canChange) {
        alert('You must wait 24 hours between username changes.');
        return;
      }
      updates.last_username_change = new Date().toISOString();
    }

    await updateUserProfile(fbUser.id, updates);
    fbProfile = { ...fbProfile, ...updates };
    
    profilePicEl.style.backgroundImage = avatarUrl ? `url(${avatarUrl})` : '';
    profileBioEl.textContent = newBio || 'No bio yet.';
    document.querySelector('.main-profile-name').textContent = newUsername || fbUser.email;
    
    displayBadge(selectedBadge);
    
    profileModal.setAttribute('aria-hidden', 'true');
    profileModal.style.display = 'none';
    
    alert('Profile updated!');
  });

  async function checkUsernameCooldown(profileObj) {
    if (!profileObj?.last_username_change) return true;
    const lastChange = new Date(profileObj.last_username_change).getTime();
    const hoursPassed = (Date.now() - lastChange) / (1000 * 60 * 60);
    return hoursPassed >= COOLDOWN_HOURS;
  }

  // Menu functionality
  const menuToggle = document.getElementById('menuToggle');
  const slideMenu = document.getElementById('slideMenu');
  const menuOverlay = document.getElementById('menuOverlay');

  menuToggle.addEventListener('click', () => {
    slideMenu.classList.add('open');
    menuOverlay.classList.add('visible');
  });

  menuOverlay.addEventListener('click', () => {
    slideMenu.classList.remove('open');
    menuOverlay.classList.remove('visible');
  });

  document.getElementById('logoutBtn').addEventListener('click', async () => {
    await supabase.auth.signOut();
    window.location.href = '/pages/loginblacknote.html';
  });

  // Offline detection
  window.addEventListener('online', () => {
    offlineBanner.style.display = 'none';
  });

  window.addEventListener('offline', () => {
    offlineBanner.style.display = 'block';
  });
</script>

</body>
</html>